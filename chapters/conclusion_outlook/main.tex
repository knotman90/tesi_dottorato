\chapter{Conclusion}
\label{ch:conclusion}

\dictum[Marcel Proust]{%
   Forse l'immobilità delle cose intorno a noi è loro imposta dalla nostra certezza che sono esse e non altre, dall'immobilità del nostro pensiero nei loro confronti.}
\vskip 1em

Computers performance improvements  have usually come from adding more transistors onto silicon or increasing the clock speed of the chips.
As stated by the Moore's law, computer systems performance has growth steadily since the 70's at a pace of almost a twofold improvement every two years.
But this trend is not sustainable since cramming more transistors or increasing the clock speed require more power, which in turn generates more heat.
Modern chips have already a ratio of heat over cm$^2$ that is higher of that of nuclear reactor core and transistors size is also hard to shrink since their size is already almost of the same order of magnitude of a single atom.


Demand for speed did not stop over the years and thus in order to be able to create computer systems able to tackle the challenges posed by the modern big-data and scientific computing fields. it is necessary to use multiple computing cores and nodes concurrently. Parallel computing is ubiquitous as even low-end smartphones feature, multi-core processors but parallel dedicated machines have evolved over years into complex and hardware heterogeneous agglomerate of computing devices in order to be able to solve bigger and bigger instances. Programming this ecosystem of devices, each with its own peculiarity in terms of hardware architecture and programming model and tools, at his full efficiency is notoriously hard, especially for non specialized computer scientist because specialized knowledge (algorithms, tools, programming languages, systems tools, high-speed networking, etc.) is absolutely necessary.

This work aimed at the design of a programming abstraction for seamless implementation of numerical methods on regular grid targeting a plethora of different parallel computer architectures: from commodity PC, to large clusters of accelerators. The \texttt{OpenCAL} framework has been developed which exposes a domain specific language for the definition of a large class of numerical models and their subsequent deployment on the targeted machines.
At this stage of development there are a number of specialized implementation of \texttt{OpenCAL} each targeting a different architecture (or a mix of them).
Each version was designed to be the most reliable and fast possible
and, for this purpose, the C/C++ language was adopted and efficient data
types and algorithms considered. In particular, also to permit a
more straightforward OpenCL parallelization, linearized arrays were
adopted to represent both one-dimensional and higher order
structures like substates and neighborhoods. 


Though preliminary, obtained results confirm correctness and
efficiency of the different \texttt{OpenCAL} versions here presented, by
highlighting their goodness for numerical model development of
complex systems in the field of Scientific Computing and their
execution on parallel heterogeneous devices.
Among all versions,  \texttt{OpenCAL-CLUST} targets distributed memory machines and multi-accelerators architectures.
Results show that \texttt{OpenCAL} allows deploying numerical applications on regular grid on machines composed by several computational nodes interconnected by network each armed with multiple accelerators. Thanks to the adoption of \texttt{OpenCL}, different kinds of accelerators can be employed seamlessly and efficently.
The performance benchmarks that have been used to test OpenCAL-CLUST show that it effectively use the computational power of multiple devices in order to speedup the computation.

As regarding future developments, \texttt{OpenCAL} will be  extended allowing domain decomposition on multiple dimensions. As shown in Section \ref{sec:domain_decomposition}, decomposing the domain on a single dimension is not always optimal, as in order to obtain better load balancing among the devices different decomposition may be necessary.
The programmer would be able to decompose the domain multidimensional cubic portions and assign one to each available device.
Another important issue that will be addressed is that the current implementation serializes communications at each step execution taking advantages of possible computation-communication overlapping.
Another limitation that the current implementation exposed is that boundaries are always exchanged among intra-node devices. This might not be optimal in cases where boundaries grid cells between two devices or nodes do not change and thus, the communication of such cells avoided. This mechanism can be accomplished by performing boundaries exchange only if there is a relevant update i.e. by means of the so called \textit{dirty-bits} mechanism. 
A scaling benchmark will be performed on a proper \textit{HPC} cluster with at least $16$ nodes interconnected by fast network (\texttt{Infiniband} et. similia for instance) in order to obtain information about the scalability of \texttt{OpenCAL} as the number of nodes is increased.
Nevertheless, a fine tuning of underlying data structures and
algorithms. As regard the OpenCL implementation, the seamless management of GPUs local memory will be introduced in the next releases.
Subsequent releases will also progressively support further computational
paradigms, like the Lattice Boltzmann, the Smoothed Particle
Hydrodynamics (SPH), as well as other mesh-free numerical methods,
with the aim to become a general software abstraction layer for
computation.

The \texttt{OpenCAL} software libraries, together with a comprehensive
installation and user manual accompanied by numerous examples, are
currently freely available on GitHub, at \url{https://github.com/OpenCALTeam/opencal}.




%1- riassumi capitolo per capitolo cosa hai visto nella tesi
%2- riassumi il contributo più importante e.g. opencal riesci a parallelizare modelli fdm e XCA in modo trasparente su architetture multicore differenti
%3- mostra che i risultati sono buono
%4- dici che ci sta tanto da fare (prendi outlooks and future works dai capitolo opencal.tex e opencalcluster.tex e bacteria)




